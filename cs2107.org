#+TITLE: CS2107
#+AUTHOR: Joshua Wong

* Lecture 1

** Definitions
1. *Threat* is the set of circumstances that have an ability to harm
2. *Vulnerability* is the weakness is the system

This is commonly generalized as the *asset-threat-vulnerability-control model*.

1. *Confidentiality* is to ensure that info is only viewed by authorized parties. Also known as privacy
2. *Integrity* is to ensure that asset is only modified by authorized party
3. *Availability* is to ensure that asset can only be used by authorized party at any time
4. *Authenticity* is logins, password checks, msg sender/origin etc - asset is from the source it claims to be.
5. *Accountability*, such as the non repudiation of a prior agreement.

** Encryption
Cryptology vs Cryptography - Study of codes vs study of techniques in securing comms in the presence of adversaries.

Encrpytion is one of the primitives in cryptography.

#+CAPTION: Encryption process
#+ATTR_ORG: :width 600
[[file:./images/cs2107_l1_1.png]]

*** Requirements for encryption
1. \(D_k(E_k(x))\) where \(k\) is the key. This is known as correctness.
2. Must be difficult to get useful information from the ciphertext.
3. Efficent decryption and encryption. (polynomial time)

* Lecture 2
** Attacking cryptography

The first way to do this is via exhaustive searching, that is, trying out all the possible keys in the key space
and then hoping that you get the right answer. This is of course bounded by the key space and the key space size

Next is the known plaintext attack. Given a plaintexxt and the corresponding cipher text, check if it is possible to get the key

Lastly, the ciphertext only attack. This checks whether given only the cipher text, the plain text can be decrypted.

** Classical Ciphers

| Name                | Description                                     | Insecure under plain text                      | Insecure under cipher text                                                    | Remarks                                                                   |
|---------------------+-------------------------------------------------+------------------------------------------------+-------------------------------------------------------------------------------+---------------------------------------------------------------------------|
| Substitution Cipher | 1-1 mapping of letter to letter                 | Yes, given long enough cipher text             | Yes, frequency analysis                                                       |                                                                           |
| Vigenere (Shift)    | Use a keyword to as key                         | Yes                                            | Yes, if we can find the length of the period, k, we can do frequency analysis | See Kasiski method                                                        |
| Permutation         | Group into blocks of t, then permute each block | Yes                                            | Yes, check if permutation gives valid word                                    |                                                                           |
| One Time Pad        | Using n bit key and n bit message, XOR each bit | You can, but the key is useless (one time use) | No, not clear how to exhaustive search and leaks no info apart from msg size  | Key must be as long as message and sent on secure channel so not too good |

*Kasiski method: Look for same letter blocks in the cipher text and see how far they are apart. This might gives clues about the period/keyword size of vigenere.

** Security

*** Review
Formula can be represented as \(G, E, D\) over \(K, M, C\) where G is the key generator, E encryption, D decryption, K the key set, M the plaintext set and C is the ciphertext set

- Requirement: For all \(\forall m \in M\) and \(\forall k \in K\), \(D_k(E_k(x))\).
- Effiency: G, E, D should run in polynomial time
- Security: Attacker cannot recover secret key or plaintext

*** Perfect Security
Regardless of any prior info attacker has, with unlimited power, cipher text should leak nothing about plain text.

But for this to occur, key must be as long as plaintext => impractical

*** Computational Security
Okay if cipher leaks some info with tiny probability to attacker with bounded computational resources. Failure is considered negligible in practice.

We measure the strength by the estimated number of bits in the key or equivalent exhaustive search => aim for 2^128 and above. For example, even though RSA has 2048 bits, it has exploits that make its search take arounf 2^112, so it is a 112 bit strength key.

** Modern Ciphers

Take into account all attacks, and no exploits should be faster than exhaustive search.

#+NAME: Block cipher
#+ATTR_ORG: :width 300
[[file:images/cs2107_l2_1.png]]

#+NAME: Stream cipher
#+ATTR_ORG: :width 300
[[file:images/cs2107_l2_2.png]]

#+NAME: Stream vs block cipher
#+ATTR_ORG: :width 300
[[file:images/cs2107_l2_3.png]]

*** Stream Ciphers

Given a secret key of smaller size, generate a sequence of same size as message, and then take sequence as key in one time pad.

There are some constraints. Firstly, the key generator must generate a cryptographically secure psuedorandom sequence called the key stream. Cryptographically secure means that it must pass all efficient statistics test and be unpredictable. Psuedorandom means that iit should be indistinguishable from random set.

The psuedorandom generator should map a seed space to an output space in a deterministic fashion. However, this is not good as same seed == same keystream (two key issue in one time pad).

Initial Value (IV) is the solution to this. IV can be a random value or chosen form a counter. A long sequence is generated from secret key using IV as seed. The final cipher text contains the IV, else the recieving end also cannot generate the key to decrypt.

IV is important as without the IV, given a plaintext message X and Y, if the attacker eavesdrops and obtains the corresponding cipher texts U and V, it can get the message X XOR Y, which may be bad for messages like images.
But with different keys from different IVs, the result is (X XOR Y) XOR (K1, K2), where K1 is not K2.
* Lecture 3

** Block Cipher
Is an important crypto primitive. For block cipher, M = C = {0, 1}^n with n = block size

The longer the key is, the more secure the scheme but the slower it is.

** Keyed Pseudorandom Permutation - E: K x X -> X
- There exists an efficient deterministic algo to evaluate E(k, x)
- Output looks random
- E is bijective and hence length preserving
- There exists efficient inversion algorithm (decryption)

The block cipher can be seen as a permutation function that maps 2^n plaintext to 2^n cipher text.
The permutation is determined by the key and different key should be mapped to different permutation. This is done by
the adorementioned keyed psuedorandom permutation.

** How Block Cipher works
An iteration of rounds. So there exist a round function f(x, k), where k may have undergone preprocessing like key expansion. In each round, the same round function is used, but the round key (subkey) is different. n different roundkey for n rounds.

** DES
Has a block size of 64 and key size of 56.

It works in 16 rounds using Feistel round function. Feistel has a substitution box for confusion and a permtutation for permutation. But this is broken

One option is to use double DES, though this can be broken by meet in the middle attack. 3 DES is okay but is is 3 times slower and only has block size of 64.

** AES
Block size of 128 bits and key size of 128, 192, or 256 bits. It uses a substitution and permutation network, different from Feistel. Currently secure.

AES is probablistic if we use a randomly chosen IV.

** Properties
Diffusion - change in plaintext will affect many parts of the cipher text.

Confusion - an attakcer should not be able to predict what happens to cipher text when one character in plaintext changes.

** Mode of operations of Block Cipher
*** ECB
Use same key for each block of plaintext - But if we do this, then if two plaintext blocks are the same, so will their ciphertext.
*** Cipher Block Chaining
Use an IV at first, then XOR with the first block, encrypt, and use that as first box of cipher text. Pass this first block also as IV to the next block and so on.
*** Counter Mode
Increment IV for each block => then we encrypt the IV and XOR with the block like in one time pad to generate the output.

** Attacks
*** Meet in the Middle
This has been explained in the earlier section under DES.
*** Padding Oracle Attack
Given a cipher text and IV, the Padding Oracle lets us know if the plaintex has the correct padding format. We pad when the last block of plaintext is not the same size as the block size, the pad.
Standard padding formats include PKCS#7.

In CBC decryption, each cipher text is passed through the decryption cipher, and XORed with the previous cipher text.

#+TITLE: Figure 1
#+ATTR_ORG: :width 400
[[file:images/cs2107_l3_1.png]]


Notice that I' = C1 XOR P and P = C1 XOR I', where C1 is the preceeding block.
