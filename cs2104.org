#+TITLE: CS2104
#+AUTHOR: Joshua Wong

* Lecture 1 :CS2104:
** Benefits of PL features
- Readability
- Extensibility
- Modifiability
- Reusability
- Correctness
- Easy debugging
 
** Haskell features
- Strongly typed with polymorphism
- Higher order function
- Pure and lazy function
- Algebraic
- Exceptions
- Type classes, monads, arrows

** OCaml vs Haskell vs Scala
#+BEGIN_SRC haskell
putStrLn "Helloworld" -- String = IO() String to IO Monad
#+END_SRC

#+BEGIN_SRC ocaml
print_endline "HelloWorld" // String -> () the printing is a side effect
#+END_SRC

OCaml supports imperative programming

In Scala, you can declare functions as objects - including static ones

** Lambda Calculus
Lambda calculus is the simplest language out there. It is turing complete and supports features like boolean, loops and data structures.

*** Terms of Lambda Calculus
There are 3 types of terms in lambda calculus
 1. Variable, eg \(\ x \)
 2. Also used for abstraction: \(\Lambda . x\), think of this as function
 3. Applying a function to an argument (Application), \( \mu \: \nu \)

** Functional Programming
Usually, a pure functional language has no update or side effects to allow for easy debugging and abstraction

This paradigm is known as *declarative programming*, which focuses on what is to be done as opposed to how it is done.
Functions and relations are the focus.

There is also usually no state. Simple data transforms are used and especially for Haskell, the data structures are immutable.

* Lecture 2
** Local Binding
Local Binding is a construct to declare a new identifier. The bindings can be either immutable or mutable.
Examples of binding include method params, local vars, pattern matching.

- In Haskell, local variable binds are immutable and the definitions are also recursive by default. OCaml on the other hand is not recursive by default.
- For /x in y/ Haskell expressions, the /y/ is the one returned to the caller.

** Typeful Expressions
#+TITLE: Typeful expressions
#+BEGIN_SRC  haskell
e::t where e is the expression and t is the type

use :t to get the type
#+END_SRC

Haskell also supports type class mechanisms. More about this later, but basically a type class allows us to declare which types are an instance of which class which provides
definitions of the poverloaded operations of said class

** Function Declarations
In Haskell, functions can also be defined via the /let/ keyword because functions are also values.
Haskell also supports multiple and recursive definitions via layout rule.

#+TITLE: Definitions
#+BEGIN_SRC haskell
let quad x =
      let add x y = x + y -- These are nested definitions
          double x = add x x
      in (double x) + (double x)

-- Also, by default, Haskell evaluates function arguments in a left associative nature due to the high precedence of space
-- a b c = (a b) c
-- Use the $ operator a $ b c to change it to a (b c)
#+END_SRC

Also, putting a '' around an infix operator turns it into a prefix operator, like any other Haskell functions. This applies to math operators like /*-+/.

** Data Types
Primitive types are usually very simple, like char and int. It is possible to have a language without primitive types,
like Lambda calculus, but often these are less performant.

Types in Haskell are very high level, and usually are boxed types. It can help to think of boxed and unboxed as analogous to objects/primitives in Java.

/data Int = Int#I#/

Types have also a strong correspondence to logic. This is known as the *Curry Howard Correspondence*

*** Why Boxed
1. Polymorphism requires boxed types. Primitive types have fixed sizes, so when declaring things like list, we
   don't know how much to allocated, but with boxes, we can allocate a constant pointer size
2. Lazy Evaluation as primitives have to be evaluated in order to store it somewhere. Compare this to boxes, where we can
   just store a pointer to the suspended operation and then evaluate it whenever necessary.

*** User Defined Types

**** Sum Type (Core)
This will include things like /t1 | t2 | t3/. This is analogous to disjunction

Includes ordinal and algebraic types

**** Product Type (Core)
This will include things like /(t1, t2, t3)/. This is analogous to conjunction

Includes records and tuple types

**** Record Type
This is very similar to a C struct
#+TITLE: Record
#+BEGIN_SRC c
struct Record {
    int num,
    char name[],
}
#+END_SRC

The types are associated with the fields

Record Types are immutable by default in OCaml and it is encouraged.

**** Union Type
Union type is similar to record, except that there is only one field at one time.
So, the fields overlay each other, and the memory allocated to the type is usually the memory required by the largest type the union type can be.

**** Algebraic Type
This is very similar to the union type, except safer and with data constructor tags

**** Pointer Type
Not seen in Haskell, because algebraic data type already implemented as a pointer to boxed value. But in C is meant to capture the address of an object value.

Pointer types are crucial for recursive data type in C. Recursive types are possible in Haskell but can be infinite. NOTE: Don't confuse this with type synonyms.

**** Tuple Type
Tuple differ from record types in that they have no field name, just access by position

**** Ordinal Type
Like an enum, it is also a special case of Algebraic type, because some enums can have operations like additions performed on them etc.

**** Type Synonyms
Type synonyms cannot be recursive in Haskell, unlike in C.

**** Untyped Languages
Essentially just sums different types togther, but without no constructor tags then there is no type safety that can be ensured at both compile and runtime.

*** Pattern Matching
#+NAME: Pattern Matching
#+ATTR_ORG: :width 500
[[file:images/cs2104_l2_1.png]]

** Type Classes
Type classes is like polymorphism for types => defining types by the operations they can potentially support. Like polymorphism, can support overloading.

#+BEGIN_SRC haskell
class Eq a where
  (==), (/=) :: a->a->Biik
  x /= y = not (x == y)
#+END_SRC

Type classes can be extended and open.

#+BEGIN_SRC haskell
instance Eq Integer where
  x == y = x 'integerEq' y
#+END_SRC

Recursive types can be handled but elements need to be given type qualifiers.

*** Class Extension
Haskell also supports the notion of extending from some base class type.

#+BEGIN_SRC haskell
class (Eq a) => Ord a where
  (<), (<=), (>), (>=) :: a->a->Bool
  max, min :: a->a->a
#+END_SRC

Multiple inheritance is also supported.

** Enumeration Class
Supports syntatic sugar for arithmetic sequences /[a..b]/

** Show class
Show class is for types that can be converted to the character string.

** Read Class
Handles the converse of parsing a data structure from a string

** Derived instances
Helps with writing instances for standard type classes can be tedious.

** Direct Handling
Use Maybe type or Either type.

** Language Constructs
For Haskell, we mainly use expression oriented constructs

#+TITLE: Expression Oriented Construct
#+ATTR_ORG: :width 300
[[file:images/cs2104_l3_1.png]]

** Tuple vs Curried Functions
Tuple and Curried Fucntions are isomorphic, you can convert one to the other
(x, y) -> addCurry x y
\ x -> \ y -> addTuple(x, y)

** Recursion and Tail Recursion
Tail Recursion helps to keep the stack size constant.
* Lecture 4
Functions should be first class - value and type, passed as argument, returned, constructed at runtime (lambda), stored in data structures.

** Functions that returns functions
Equivalent to curried functions

** Lazy Evaluation via Function
#+BEGIN_SRC haskell
(\ () -> e)
#+END_SRC

This is very much like a thunk.

Lazy evaluation helps Haskell handle cases like infinite lists well. Though if there is a need for strict evaluation then
use the operator /!/ in front of the expression.
Another option for strict evaluation is the /seq/ keyword, which forces the strict evaluation first - /e1 'seq' e2/. Strict evlauation also occurs before pattern matching.

** Genericity
Replace each constant or function that differs by a parameter.
#+BEGIN_SRC haskell
let foldr f z xs =
      let aux xs =
            case xs of
              [] -> z -- basecase
              y:yx -> f y (aux ys)
      in aux xs
#+END_SRC

This is an example of the fold right operator -> operate on RHS side first.

Fold left is just the opposite -> operator on the RHS first. However, a key thing to note is that fold left operators tend to be *tail recursive*.

#+BEGIN_SRC haskell
let fold l f z cs =  -- z is the accumulator original value
      let aux xs acc =
            case xs with
            | [] -> acc
            | y:ys -> aux (f acc y) ys
      in aux z xs
#+END_SRC

If the reduction /f/ is associative, then we can use fold left or fold right, if not then we have to choose between foldl and foldr carefully.

It is also not always the case that foldl has better performance foldr.

There is also a *Foldable* type class that also has a whole lotta other fold style operations.

** Mapping
map : (a -> b) -> [a] -> b

** Functor
Functor is anything that is mappable.
#+BEGIN_SRC haskell
class Functor f where
  fmap:: (a -> b) -> f a -> f b
#+END_SRC
Map is an the list implementation of fmap


** Composition
Function composition is an instance of functor fmap.
* Lecture 5
** List Comprehension
#+BEGIN_SRC haskell
[f x | x <- ys] -- this is a map
[x | x <- ys, x < 5 ] -- this is a filter
[x | x <- xs, y <- ys] -- this is a concatmap pattern
#+END_SRC
** Arrays
Regarded as functions from indices to values, but for efficient retrieval it is contigous and bounded.

Can also build an array from an association list.
#+BEGIN_SRC haskell
squares = array (1, 100) [i | i <- [1..100]]
#+END_SRC
Since haskell is purely functional, the array must be built in one step (monolithic).

*** Accumulation
#+BEGIN_SRC haskell
accumArray :: (Ix a) => (b->c->b) -> b -> (a,a) -> [Assoc a c] -> Array a b
--                      accum fn init-val bounds  elements
#+END_SRC

** Semi-Groups
#+BEGIN_SRC haskell
class SemiGroup a where
  op :: a -> a -> a
class SemiGroup a => Monoid a where
  unit :: a
#+END_SRC

There are two properties of monoids:
#+BEGIN_SRC haskell
unit `op` x = x `op` unit = x  -- unit is both left and right, its not meant to represent commutativity.
(x `op` y) `op` z = x `op` (y `op` z)
#+END_SRC

Unit is just something that gives back the operator when together with the operator. Note that the properties are not checked by Haskell => So it is up to the user to ensure that the two properties all hold.

** Monads
An expr is referentially transparent if it can be replaced with corresponding value without chaging the program's behavior.

Monads are referentially transparent, but not imperative programming with side effects.

*** Context
Values can be associated with a context, like IO, Maybe type. Once we have a context, we cannot directly apply a function. So the solution is to use the Functor and to define the /fmap/.

*** Applicatives
#+BEGIN_SRC haskell
class Functor f => Applicative (f:: *->*) where
  <*> :: f (a->b) -> f a -> f b
#+END_SRC
However, functions can also be dumped into a context. Applicatives /<*>/ are used in this scenario, because fmap does not apply to functions, only to a value inside a context (See its type defn).
#+BEGIN_SRC haskell
fmap :: (a->b) -> f a -> f b -- type of a is value not a function
#+END_SRC

*** Monads actual
#+BEGIN_SRC haskell
class Monad m where
  (>>=) ::  m a -> (a -> m b) -> m b
#+END_SRC
