#+TITLE: CS2102

* Lecture 1 :CS2102:
** Basic terminology
We typically use tables to represent relations as all relations can be expressed as tables. Not vice versa

The data is represented via attribute values we are interested in. These values cannot be decomposed (atomic).

- A *value* is the each "cell" in the database.
- An *attribute* is the header of the column. If you view the column as a set, then it is the name of the set
- A *schema* is an ordered row of all the attributes of the table.
- A *domain* is the unique set of all values of an attribute w/o the attribute name itself.
- *Arity* is the number of attributes/columns in the table.
- *Cardinality* is the number of rows, though this is often less important.
- *Relational Database Schema* is the schemas of tables that make up a database. Data can be omitted. Often contains *constraints*.

** Logical Groundings
If we see each table column as a set, then it is easy to see tables as a subset of the Cartesian product of all the table columns. Subset because of course there are some cartesian product values that we do not use.

** Anatomy of Database
For there to be valid data, there needs to be a relation instance that satisfy certain constraints. Constraints can come in the form of types like /VARCHAR, INT/ etc, or stuff like key constraints

*** Keys
**** Superkey
Superkeys are a combination of attributes that can be used to uniquely identify data (a row of values).

For example, this may take the form of /(Height, Name)/ or /(ID)/
**** Key
Key is a minimal superkey, in other words, a superkey set that does not contain a smaller superkey. Note that this is not the minimum superkey

Using the example above /(Height, Name)/ and /(ID)/ are both keys but ID is the minimum superkey because it has the least attributes
**** Primary Key
Primary key is just the key that the user uses to uniquely identify each row/data in the table.
**** Foreign Key
Also known as existential dependency
This is applied to an attribute, and all values of this attribute now depend on the existence of another value on a different row on the same table or different table

Acts as a link between the 2 tables by referencing primary key of another table.
Foreign keys used to accept null values, but deprecated as of later SQL versions.

Insertion of Foreign Keys looks like that - If anyone of the value is /NULL/, insert. Else if it exist, also can insert into the referencing table. Must also reference primary keys.

If its an individual reference, then we must do the comparison individually. What this means is that we do the comparison column by column, checking if that value is NULL or present in the table. With multiple references, then we can just do an OR comparison with /NULL/ values, that is, if any of the columns are /NULL/, then it is ok to insert. See [[https://coursemology.org/courses/1904/assessments/39097][Lecture 01C: Foreign Key]] for more details

** Three Valued Logic of SQL
SQL has 3 forms of logic: True, False and Unknown (NULL)

NULL often lends itself to some weird logic. For example, the relationship /NULL && true/ evaluates to NULL, because the result is not known
(Could be true or false depending on actual value of /NULL/)

There may be different "types" of NULL as well: For example, /True && NULL/ evaluates to /NULL/, but so does /1 + NULL/

NULL just means could be anything. As such, it is not possible to use an equality sign with NULL, because how can you possibly check the equality of two values that mean nothing.
To do this, we use the /IS NOT DISTINCT/ operator. /NULL/ and /NULL/ are not distinct.

* Lecture 2
** Relational Calculus vs Relational Algebra
Relational Calculus is more declarative, as compared to relational algebra which is more imperative.

** Key concepts

Universal Relation/Table. The relations in the DB can be seen as one giant table and relation. This will come in handy later for stuff like cartesian products.

** Unary Operators

*** \(\sigma\) - Selector
This just selects rows from the table based on a given criteria. It selects whole rows, ie to say does not remove column etc

*** \(\pi\) - Projection
Projection selects columns from the table. The result is a set, so if there are some results that are duplicated, it will be removed by the operation

*** Rename
Rename just renames the columns/attribute names, it renames all the attributes at once.

** Binary Operators
1. & Intersection
2. | Union
3. - Difference
4. x Cartesian product (Pick one form LHS and match with each from RHS.). Note that cartesian products are non-commutative and non-associative

Stuff like cartesian products come in handy when we have to do selection from multiple tables.

*TIP*: Cartesian products can usually be made smaller and more performant by doing selection before cartesian product.

*** Union compatability
The above operations require union compatability to work. There are two conditions
1. Same arity (number of cols)
2. Same domain (type) for each attribute

** Closures
  Given a set of operators \(O\) and a set \(S\), \(S\) is a closure iff for every operator in \(O\), the input to the operator and the output are in \(S\).

  For the binary operators given above and the relations, the relations is a closed set.

** Joins
*Dangling Tuple* are tuples in join operands that do not participate in a join operation.

Inner joins remove any dangiling tuples whereas outer joins add them with a /NULL/ value.

Full outer join can be represented by left outer join \(\cup\) right outer join.
Below is a good image to show the differences between the various outer joins. Note the positioning of the /NULL/ values.

#+NAME: Outer joins
#+ATTR_ORG: :width 600
[[file:images/cs2102_l2_2.png]]

Natural joins are like inner joins, except that they just remove the corresponding attributes which are the same during the join. There is also no /NULL/.

#+NAME: Natural Join
#+ATTR_ORG: :width 600
[[file:images/cs2102_l2_1.png]]
